# 拼多多面试

## Vue如何实现响应式

当你把一个普通的 JavaScript 对象传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的属性，并使用 [`Object.defineProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些属性全部转为 [getter/setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters)。`Object.defineProperty` 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 [vue-devtools](https://github.com/vuejs/vue-devtools) 来获取对检查数据更加友好的用户界面。

每个组件实例都对应一个 **watcher** 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

![Vue响应原理](../imgs/Vue响应原理.png)

## React组件通信的方式



## React事件机制



## React创建组件的方式及其区别



## React纯函数组件



## 箭头函数



## 块级作用域



## cookie session localstorage 区别，跨域

 ` cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
`  cookie`数据始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器间来回传递。
 ` sessionStorage`和`localStorage`不会自动把数据发给服务器，**仅在本地保存**。

  存储大小：
  	`cookie`数据大小不能超过4k。
  	`sessionStorage`和`localStorage` 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

  有效时间：
  	`localStorage`    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
  	`sessionStorage`  数据在当前浏览器窗口关闭后自动删除。
  	`cookie `        设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。

`作用域` —— 谁拥有数据的访问权

- `localStorage`: 在同一个浏览器内，`同源文档`之间共享 localStorage 数据，可以互相读取、覆盖。
- `sessionStorage`: 与 `localStorage` 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据

Session是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在**文件、数据库或者集群**中。

在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。

**大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器**

## Ajax跨域



## 无宽高的弹窗居中

1. `position:absolute; top:0; bottom:0; left:0; right:0; margin:auto;`
2. `position：absolute; left:50%；top:50%; transfrom:translate(-50%,-50%);` ^IE7
3. `display:flex; justify-content:center; align-items:center` ^IE8
4. `display:box; box-pack:center; box-align:center; 
   display:-webkit-flexbox; -webkit-box-pack:center; -webkit-box-align:center; ` no IE,  others with prefixs

## 滥用div标签造成的后果





## Flex布局水品居中和填充满整个页面的操作



#  二面 

太难了。。。 也许是我太菜了吧。。。



## 为什么 getDerivedStateFromProps 是静态的 static

先说结论： **它被设计成静态方法的目的是保持该方法的纯粹，它就是用来定义衍生state的，除此之外不应该在里面执行任何操作。这样开发者就访问不到`this`也就是实例了，也就不能在里面调用实例方法或者setsState了。**

首先，这是一个静态方法生命周期钩子。

也就是说，定义的时候得在方法前加一个`static`关键字，或者直接挂载到class类上。

简要区分一下实例方法和静态方法：

- 实例方法，挂载在`this`上或者挂载在`prototype`上，class类不能直接访问该方法，使用`new`关键字实例化之后，实例可以访问该方法。
- 静态方法，直接挂载在class类上，或者使用新的关键字`static`，实例无法直接访问该方法。

问题是，为什么`getDerivedStateFromProps`生命周期钩子要设计成静态方法呢？

这样开发者就访问不到`this`也就是实例了，也就不能在里面调用实例方法或者setsState了。

**这个生命周期钩子的使命是根据父组件传来的props按需更新自己的state，这种state叫做衍生state。返回的对象就是要增量更新的state。**

它被设计成静态方法的目的是保持该方法的纯粹，它就是用来定义衍生state的，除此之外不应该在里面执行任何操作。

这个生命周期钩子也经历了一些波折，原本它是被设计成`初始化`、`父组件更新`和`接收到props`才会触发，现在只要渲染就会触发，也就是`初始化`和`更新阶段`都会触发。



## 讲一下jsx children

**如果你看过React的文档你就会说“children是一个不透明的数据结构”。从本质上来讲， `props.children` 可以使任何的类型，比如数组、函数、对象等等。**

### 如何操作children

- 循环 `React.Children.map`
- 计数`React.Children.count`
- 转换为数组 `React.Children.toArray`
- 执行单一child `React.Children.only`
  - 这样只会返回一个child。如果不止一个child，它就会抛出错误，让整个程序陷入中断——完美的避开了试图破坏组件的懒惰的开发者。
- 编辑children
- 改变children属性 `renderChildren`
- 克隆children `React.cloneElement`

原文： https://segmentfault.com/a/1190000011527160

### jsx函数里面可以写什么语句

像赋值语句、判断语句和循环语句JSX都不支持。

那开发者要渲染一个列表怎么办？

for循环语句肯定是不行的，好在我们有map函数。因为从上例我们知道，JSX是支持函数执行表达式的。

forEach函数行不行呢？不行，因为它没有返回值。也就是说，filter、find、reduce等有返回值的遍历函数都是可以的。

- 为什么返回多个标签或组件必须要用一个标签或组件包裹？
- 为什么在根本没有使用`React`这个变量的情况下还要`import React`？

**因为JSX不是正确的JavaScript语法，它要经过编译才能被浏览器识别。**

目前JSX的编译工作是由babel来完成的。

编译前：

```jsx
const app = (
    <div className="form">
        <input type="text" />
        <button>click</button>
    </div>
);
```

编译后：

```jsx
const app = React.createElement(
    "div",
    { className: "form" },
    React.createElement("input", { type: "text" }),
    React.createElement(
        "button",
        null,
        "click",
    ),
);
```

可以看到，标签最后变成了一个函数执行表达式，第一个参数是标签名，第二个参数是属性集合，之后的参数都是子标签。

整个UI实际上是通过层层嵌套的`React.createElement`方法返回的，所以我们要在文件开头`import React`，否则编译后就会发现`createElement`没有定义。

`React.createElement`执行的结果是一个对象，对象的属性描述了标签或组件的性状，对象再嵌套子对象。如果顶层返回多个标签，就无法表达为一个对象了。

由于React16引入了Fiber机制，使得返回多标签成为可能。（也就是可以返回数组了，简单讲就是：Fiber 依次通过 return、child 及 sibling 的顺序对 ReactElement 做处理，将之前简单的树结构，变成了基于单链表的树结构，维护了更多的节点关系。）

## 讲一下React Fiber



## Babel 转码原理



## 垫片是用来干什么的



## 讲一下AST













